//! Instructions for email
use {
    arrayref::{
        array_ref,
    },
    solana_program::{
        instruction::{AccountMeta, Instruction},
        program_error::{ProgramError},
        pubkey::Pubkey,
        // program_option::COption,
        sysvar,
    },
    std::{
        result::Result,
        // convert::TryInto,
        mem::size_of,
        vec::Vec,
        // str,
    }
};
use crate::{error::Sol2SolError};

#[repr(C)]
#[derive(Clone, Debug, PartialEq)]
/// Instructions supported by the email program.
pub enum Sol2SolInstruction {
    /// InitializeSolBox
    InitializeSolBox {
        /// owner of the sol box
        owner: Pubkey,
        /// How many messages will this box store
        num_spots: u32,
        /// Address of next box for extra entries
        next_box: Pubkey,
        /// Address of prev box, prevBox == self if root
        prev_box: Pubkey,
    },
    /// Send email from one wallet address to another
    WriteMessage {
        /// Which address is sending the email
        sender: Pubkey,
        /// Which address is the email for
        recipient: Pubkey,
        /// Address of message
        message_pubkey: Pubkey,
        /// Which box to send it to
        sol_box_pubkey: Pubkey,
        /// How large is the email
        msg_size: u32,
        /// What is the utf-8 data of the email
        msg_string: String,
    },
    /// Delete message & reclaim lamports
    DeleteMessage {
        /// To ensure we are deleting the right message 
        owner: Pubkey,
        /// Account of message to be deleted
        message_id: Pubkey,
        /// Where the message is located
        sol_box_id: Pubkey,
    }
}
impl Sol2SolInstruction {
    /// Unpack the given bytes into an email
    pub fn unpack<'a>(input: &'a [u8]) -> Result<Self, ProgramError> {
        let (tag, rest) = input.split_at(1);
        Ok(match tag[0] {
            0 => {
                let (owner, rest) = Self::unpack_pubkey(rest)?;
                let (num_spots, rest) = Self::unpack_size(rest)?;
                let (next_box, rest) = Self::unpack_pubkey(rest)?;
                let (prev_box, _rest) = Self::unpack_pubkey(rest)?;
                Self::InitializeSolBox {
                    owner,
                    num_spots,
                    next_box,
                    prev_box
                }
            }
            1 => {
                let (sender, rest) = Self::unpack_pubkey(rest)?;
                let (recipient, rest) = Self::unpack_pubkey(rest)?;
                let (message_pubkey, rest) = Self::unpack_pubkey(rest)?;
                let (sol_box_pubkey, rest) = Self::unpack_pubkey(rest)?;
                let (msg_size, rest) = Self::unpack_size(rest)?;
                let (msg_string, _rest) = Self::unpack_msg(rest, msg_size as usize)?;
                Self::WriteMessage {
                    sender,
                    recipient,
                    message_pubkey,
                    sol_box_pubkey,
                    msg_size,
                    msg_string
                }
            }
            2 => {
                let (owner, rest) = Self::unpack_pubkey(rest)?;
                let (message_id, rest) = Self::unpack_pubkey(rest)?;
                let (sol_box_id, _rest) = Self::unpack_pubkey(rest)?;
                Self::DeleteMessage {
                    owner,
                    message_id,
                    sol_box_id,
                }
            }
            _ => return Err(Sol2SolError::InvalidInstructionData.into()),
        })
    }

    fn unpack_pubkey(input: &[u8]) -> Result<(Pubkey, &[u8]), ProgramError> {
        if input.len() >= 32 {
            let (key, rest) = input.split_at(32);
            let pk = Pubkey::new(key);
            Ok((pk, rest))
        } else {
            Err(Sol2SolError::InvalidInstructionData.into())
        }
    }

    fn unpack_size(input: &[u8]) -> Result<(u32, &[u8]), ProgramError> {
        if input.len() >= 4 {
            let (_, rest) = input.split_at(4);
            let bytes = array_ref![input, 0, 4];
            let size = u32::from_le_bytes(*bytes);
            Ok((size, rest))
        } else {
            Err(Sol2SolError::InvalidInstructionData.into())
        }
    }
    
    fn unpack_msg<'a>(input: &'a [u8], msg_size: usize) -> Result<(String, &'a [u8]), ProgramError> {
        if input.len() >= msg_size {
            let mut utf8_bytes = Vec::new();
            for i in 0..msg_size {
                utf8_bytes.push(input[i]);
            }
            let msg_decoded = String::from_utf8(utf8_bytes);
            match msg_decoded {
                Ok(msg_data) => {
                    let (_, rest) = input.split_at(msg_size);
                    Ok((msg_data, rest))
                },
                Err(_) => {
                    Err(Sol2SolError::InvalidAccountData.into())
                }
            }
        } else {
            Err(Sol2SolError::InvalidInstructionData.into())
        }
    }

    /// Packs instruction into a vec buffer
    pub fn pack(&self) -> Vec<u8> {
        let mut buf = Vec::with_capacity(size_of::<Self>());
        match self {
            Self::InitializeSolBox {
                owner,
                num_spots,
                next_box,
                prev_box,
            } => {
                buf.push(0);
                buf.extend_from_slice(&owner.to_bytes());
                buf.extend_from_slice(&num_spots.to_le_bytes());
                buf.extend_from_slice(&next_box.to_bytes());
                buf.extend_from_slice(&prev_box.to_bytes());
            }
            Self::WriteMessage {
                sender,
                recipient,
                message_pubkey,
                sol_box_pubkey,
                msg_size,
                msg_string,
            } => {
                buf.push(1);
                buf.extend_from_slice(&sender.to_bytes());
                buf.extend_from_slice(&recipient.to_bytes());
                buf.extend_from_slice(&message_pubkey.to_bytes());
                buf.extend_from_slice(&sol_box_pubkey.to_bytes());
                buf.extend_from_slice(&msg_size.to_le_bytes());
                Self::pack_msg(&msg_string, &mut buf);
            }
            Self::DeleteMessage {
                owner,
                message_id,
                sol_box_id,
            } => {
                buf.push(2);
                buf.extend_from_slice(&owner.to_bytes());
                buf.extend_from_slice(&message_id.to_bytes());
                buf.extend_from_slice(&sol_box_id.to_bytes());
            }
        };
        buf
    }

    fn pack_msg(msg: &String, buf: &mut Vec<u8>) {
        let msg_str: &[u8] = msg.as_bytes();
        // println!("\tMsg str is: {} and has size {}", msg, msg_str.len());
        buf.extend_from_slice(msg_str);
    }

}

/// Creates an InitializeSolBox instruction
pub fn init_sol_box(
    program_id: &Pubkey,
    payer_pubkey: &Pubkey,
    sol_box_pubkey: &Pubkey,
) -> Result<Instruction, ProgramError> {
    let data: Vec<u8> = Sol2SolInstruction::InitializeSolBox {
        owner: *payer_pubkey,
        num_spots: 20 as u32,
        next_box: *sol_box_pubkey,
        prev_box: *sol_box_pubkey
    }.pack();

    let accounts = vec![
        // AccountMeta::new(*program_id, false),
        AccountMeta::new(*sol_box_pubkey, true),
        AccountMeta::new(*payer_pubkey, true),
        AccountMeta::new_readonly(sysvar::rent::id(), false),
    ];

    Ok(Instruction {
        program_id: *program_id,
        accounts,
        data
    })
}

/// Creates an WriteMessage instruction
pub fn write_message(
    program_id: &Pubkey,
    payer_pubkey: &Pubkey,
    recipient_pubkey: &Pubkey,
    sol_box_pubkey: &Pubkey,
    message_pubkey: &Pubkey,
    msg_size: u32,
    msg_string: &String,
) -> Result<Instruction, ProgramError> {
    let data: Vec<u8> = Sol2SolInstruction::WriteMessage {
        sender: *payer_pubkey,
        recipient: *recipient_pubkey,
        message_pubkey: *message_pubkey,
        sol_box_pubkey: *sol_box_pubkey,
        msg_size,
        msg_string: (*msg_string.to_owned()).to_string(),
    }.pack();

    let accounts = vec![
        AccountMeta::new(*message_pubkey, false),
        AccountMeta::new(*sol_box_pubkey, true),
        AccountMeta::new(*payer_pubkey, true),
        AccountMeta::new_readonly(sysvar::rent::id(), false),
    ];

    Ok(Instruction {
        program_id: *program_id,
        accounts,
        data
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_instruction_parsing() {
        let msg_string: String = "hello world!".to_owned();     // 12
        let init_msg_string = msg_string.clone();
        let msg_size: u32 = msg_string.len() as u32;            // 4
        let sender = Pubkey::new_unique();                      // 32
        let recipient = Pubkey::new_unique();                   // 32
        let message_pubkey = Pubkey::new_unique();                   // 32
        let sol_box_pubkey = Pubkey::new_unique();                  // 32
        // 12 + 4 + 32 + 32 + 1 (tag) = 113
        let instruction = Sol2SolInstruction::WriteMessage {
            sender,
            recipient,
            message_pubkey,
            sol_box_pubkey,
            msg_size,
            msg_string,
        };
        let packed_vec = instruction.pack();
        assert_eq!(133 + msg_size as usize, packed_vec.len());
        assert_eq!(145, packed_vec.len());
        
        let recreated = Sol2SolInstruction::unpack(&packed_vec[..]).unwrap();
        assert_eq!(instruction, recreated);
        match instruction {
            Sol2SolInstruction::WriteMessage{ msg_string, .. } => {
                assert_eq!(init_msg_string, msg_string);
            }
            _ => {
                // Lol manually fail test
                assert_eq!(0, 1);
            }
        }
    }

    #[test]
    fn manual_deserialize_write_message() {
        let manual_bytes = [
            0x01, 0x7d, 0xe1, 0x17, 0xe5, 0x8d, 0xb6, 0xb1, 0x6b, 0xb8, 0x6f, 0x13, 0x99, 0x4d, 0xe3, 0xb4, 0x03, 0xec, 0xf9, 0xf7, 0xf1, 0x3f, 0xfb, 0x8d, 0x1c, 0xec, 0xde, 0x14, 0xa9, 0xca, 0xc6, 0xab, 0x46, 0xfb, 0xf4, 0x62, 0xca, 0x94, 0xa1, 0x16, 0xb5, 0x7a, 0xd3, 0xb0, 0x3d, 0xc2, 0x19, 0x01, 0xc0, 0x65, 0xe1, 0xa5, 0x3f, 0x9a, 0xac, 0x0e, 0x8c, 0xaa, 0x79, 0x8b, 0xac, 0xdc, 0x1d, 0xe1, 0xc8, 0xf6, 0xc4, 0x8f, 0xa1, 0xa8, 0x8f, 0x7c, 0xfa, 0xb5, 0x02, 0x50, 0x44, 0xaf, 0x68, 0x95, 0x10, 0x9e, 0x3c, 0x5f, 0x82, 0xb5, 0x2c, 0x99, 0x38, 0xbe, 0x7f, 0xfb, 0xad, 0xf4, 0xf6, 0xc9, 0x55, 0x85, 0x8e, 0xa7, 0xd9, 0x4b, 0x0b, 0x1d, 0x20, 0xea, 0xfa, 0xeb, 0x03, 0xb5, 0x05, 0x94, 0x99, 0x34, 0x7a, 0x9e, 0xc0, 0xf2, 0x95, 0x7b, 0xb6, 0xd7, 0x8e, 0x0d, 0x86, 0x41, 0xc7, 0x6c, 0xb4, 0x0c, 0x00, 0x00, 0x00, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x20, 0x77, 0x6f, 0x72, 0x6c, 0x64, 0x21 
        ];
        let recreated = Sol2SolInstruction::unpack(&manual_bytes[..]).unwrap();
        match recreated {
            Sol2SolInstruction::WriteMessage{ msg_string, .. } => {
                // should say "hello world!"
                println!("Recreated string: [{}]", msg_string);
                assert_eq!(msg_string, "hello world!");
            }
            _ => {
                // Lol manually fail test
                assert_eq!(0, 1);
            }
        }

        println!("done!");
    }

    #[test]
    fn manual_deserialize_init_box() {
        let manual_bytes = [
            0x00, 0xe7, 0x38, 0xcc, 0x07, 0x5d, 0xd3, 0xe1, 0xaf, 0x7f, 0x14, 0x4b, 0xcd, 0x39, 0x35, 0x21, 0x3c, 0xe1, 0x3f, 0x0a, 0x1e, 0x12, 0x22, 0x79, 0x87, 0x70, 0x0e, 0x95, 0xf6, 0xc9, 0x8a, 0x8f, 0x38, 0x73, 0xf4, 0xef, 0x5f, 0xe3, 0xdb, 0x6f, 0x25, 0x40, 0x2d, 0xc2, 0xce, 0x13, 0x71, 0x62, 0xbc, 0x74, 0x74, 0x4f, 0xde, 0x84, 0xac, 0xae, 0x6b, 0x6e, 0x04, 0xfe, 0x34, 0xa3, 0xf3, 0x83, 0xc4, 0x73, 0xf4, 0xef, 0x5f, 0xe3, 0xdb, 0x6f, 0x25, 0x40, 0x2d, 0xc2, 0xce, 0x13, 0x71, 0x62, 0xbc, 0x74, 0x74, 0x4f, 0xde, 0x84, 0xac, 0xae, 0x6b, 0x6e, 0x04, 0xfe, 0x34, 0xa3, 0xf3, 0x83, 0xc4, 0x14, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9, 0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0xd9, 0xcb, 0xe1, 0x46, 0xce, 0xeb, 0x79, 0xac, 0x1c, 0xb4, 0x85, 0xed, 0x5f, 0x5b, 0x37, 0x91, 0x3a, 0x8c, 0xf5, 0x85, 0x7e, 0xff, 0x00, 0xa9
        ];
        let recreated = Sol2SolInstruction::unpack(&manual_bytes[..]).unwrap();
        match recreated {
            Sol2SolInstruction::InitializeSolBox{ owner, .. } => {
                // should say "hello world!"
                println!("Recreated owner: [{}]", &owner.to_string());
                assert_eq!(&owner.to_string(), "GZbQmKYYzwjP3nbdqRWPLn98ipAni9w5eXMGp7bmZbGB");
            }
            _ => {
                // Lol manually fail test
                assert_eq!(0, 1);
            }
        }
    }

    // #[test]
    // fn state_deserialize_invalid() {
    //     assert_eq!(
    //         FeatureProposalInstruction::unpack_from_slice(&[1]),
    //         Ok(FeatureProposalInstruction::Tally),
    //     );

    //     // Extra bytes (0xff) ignored...
    //     assert_eq!(
    //         FeatureProposalInstruction::unpack_from_slice(&[1, 0xff, 0xff, 0xff]),
    //         Ok(FeatureProposalInstruction::Tally),
    //     );

    //     assert_eq!(
    //         FeatureProposalInstruction::unpack_from_slice(&[2]),
    //         Err(ProgramError::InvalidInstructionData),
    //     );
    // }
}
